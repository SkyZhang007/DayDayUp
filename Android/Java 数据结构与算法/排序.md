# 冒泡排序
- 基础：每轮交换一个数据到合适位置，执行n轮。弊端：每次排序都会两圈遍历；
- 升级：从底部开始排序，最大值冒上来，不用每次遍历整个数组；
- 完全：发生交换之后break，后面的数据已经排序好了。

```
public void popSort(){
       int[] nums = new int[]{6,1,3,56,22,3,8};
       for(int i = 0; i < nums.length; i++){
		boolean flag = false;
              for(int j = nums.length-2;j>=i;j--){
                     if(nums[j] > nums[j+1]){
                            flag = true;
                            int temp = nums[j];
                            nums[j] = nums[j+1];
                            nums[j+1] = temp;
                     }
              }
              if(!flag){
                     break;
              }
       }
		
       for(int i=0; i < nums.length;i++){
              System.out.print(nums[i]+",");
       }
}
```

# 简单选择排序
每轮选择最小的值，进行交换

```
public static void main(String []args) {
       int[] nums = new int[]{6,1,3,56,22,3,8};
       for(int i = 0; i < nums.length; i++){
              int min = i;
              for(int j=i;j < nums.length; j++){
                     if(nums[min] > nums[j]){
                            min = j;
                     }
              }
              if(i != min){
                     int temp = nums[min];
                     nums[min] = nums[i];
                     nums[i] = temp;
              }
       }
       
       for(int i=0; i < nums.length;i++){
              System.out.print(nums[i]+",");
       }
}
```



# 插入排序
左边是排序好的数据，右边选择数据插入左边合适下标


# 快排
{4,7,3,5,6,2,8,1};
   △           △
基准 4  l=1  r=7
{4,1,3,5,6,2,8,7};
       △   △
{4,1,3,2,6,5,8,7};
       🔼
{2,1,3,4,6,5,8,7};  

return 🔼
```


```


[1,2,3,4,5,6]

