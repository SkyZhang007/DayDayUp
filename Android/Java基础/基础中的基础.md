
[Java 各版本特性](https://www.cnblogs.com/JCcccit/p/16868282.html)

# 对象
- "万物皆对象"：Java 对个体的一种描述。

## 对象间的四种关系
- 依赖：Person 可以 buy Car 或者 House，但是没有直接拥有其变量，使用的时候传递对象；买 Car 依赖于 Car 是什么样的。
- 关联：一个类知道另一个类的属性和方法，拥有另一个类的成员变量；
- 聚合：强关联关系，比如 Car 类拥有 Engine、Wheel。那么 Car 聚合这些类；
- 组合：类直接更强的关系。

## 对象的特点
- 封装：拥有私有变量和方法，形成一个整体；
- 继承：基类的封装，子类共享变量和方法；
- 多态：指的是父类拥有多种子类多种形态；
- 抽象：对类的一种更加抽象的表示。

## 装箱和拆箱
- 装拆箱既是把基本数据类型转换为包装类的和拆解的过程。

### 下面代码输出结果
```
public class Main {
   public static void main(String[] args) {        
       Integer i1 = 100;
       Integer i2 = 100;
       Integer i3 = 200;
       Integer i4 = 200;        
       System.out.println(i1==i2);//true
       System.out.println(i3==i4);//false
   }
}
```
- 第一个 true:  128~-128 内的数据会缓存，两个对象指向一个缓存；
- 超过缓存，则两个对象；
- 因为 Integer 数据单个且有限，所以换成。Double 等带小数数量太多就没做缓存。
- Boolean 拆装箱指向相同内部变量，所以所有拆出对象都相同；

### new Integer(10) 和 = 10 区别？
- 是否触发自动装箱，效率区别。一般情况下 =10 效率较高；

# 类
- 类在创建时只暴露关键的接口给外部，以免内部被破坏；
  
## 抽象类
- 抽象类不能被实例化，可以匿名创建；
- 有抽象方法一定是抽象类，子类必须实现所有抽象方法；
- 抽象方法不能为 static final 类。

## 接口
- java8 之前，接口方法都是 public abstract，只不过省略了前缀。之后，接口可以定义静态方法。

## Clone
- 复制对象且保留原有对象的操作；
- 浅拷贝，仅拷贝基本类型变量，不克隆引用类型变量；

## hashCode
- Object类提供的默认实现确实保证每个对象的hash码不同（在对象的内存地址基础上经过特定算法返回一个hash码)
  
## 内部类
- 同包下访问限制，安全；
- 可以访问外部类私有变量；

- 内部类总有一个隐式引用，指向外部类，所以可以使用外部类的方法。

## 代理 proxy
- 想要动态创建一个类，但是又不能去把它的接口什么都都实现掉。通过创建代理执行接口方法实现功能；
- 


# 高级
## 反射
- 是一种工具集，用来动态操作 Java 代码的程序。能力：
    - 运行时分析类的能力；
    - 运行时检测对象，例如为所有类添加 toString；
    - 利用 Method 方法，类似函数指针；


## lambda
- 为解决 Java 不能传递代码块的问题
- lambda（λ） 格式： () -> {} 参数、可以为空 箭头 代码块

- 函数式接口
  只有一个抽象方法的接口;
- 方法引用
  

# Question
- 为什么引入接口，而不是扩展抽象类？ 只能单继承


# 并发

## Condition
- 由 Java 代码实现、与 await awake 不同（JVM 实现）；
- 同样是阻塞和唤醒线程，在一个线程中使用 Condition 调用 lock 阻塞线程、使用该对象调用 signal 信号唤起线程；




